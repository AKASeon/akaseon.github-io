---
layout: post
title:  "Effective C++ No.23 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워 지자"
date: 2015-12-31
categories: jekyll update
---

```c++
class WebBrowser
{
public:
    ...
    void clearCache();
    void clearHistory();
    void removeCookies();
    ...
}
```

clearCache, clearHistory, removeCookies 의 세가지 기능을 하는 함수를 멤버 함수로 선언하는 방법이 있다.
```c++
class WebBrowser
{
public:
    ...
    void clearEverything();
    ...
};
```

또 비멤버 함수로 선언하는 방법이 있다.  

```c++
void clearBrowser( WebBrowser & wb )
{
    wb.clearCache();
    wb.clearHistory();
    wb.removeCookies();
}
```

위 멤버 함수로 선언하는 방법과 비 멤버 함수로 선언하는 방법중 어느것이 괜찮은 방법일까?  

객체 지향 법칙에 관련된 이야기를 찾아 보면 데이터와 그 데이터 기반으로 동작하는 함수는 한데 묶여 있어야 하며, 멤버 함수가 낫다고 하였다.  
그러나 여기에서는 멤버 함수가 좋은 방법이 아니다.  

객체 지향 법칙은 할 수 있는 만큼 데이터를 캡슐화하라고 하고 있다.  
그러나 멤버 버젼인 clearEverything 을 보면 clearBrowser 보다 캡슐화 정도에서는 형편없다.  
이것말고도, 비멤버 함수를 사용하면 WebBrowser 관련 기능을 구성하는데 있어 패키징 유연성이 높아 지는 장점이 있다.  
그로 인해 컴파일러의 의존도도 낮추고 WebBrowser 의 확장성도 높일수 있다.  
비 멤버로 방법이 멤버 함수보다 더 낫다는 이야기 이다.  

어떤 것을 캡슐화하면, 우선 외부에서 이것을 볼 수 없게 된다.  
캡슐화하는 것이 늘어나면 그 만큼 밖에서 볼수 있는것이 줄어든다.  
밖에서 볼수 있는 것이 줄어들면, 그것들을 바꿀때 필요한 유연성이 커진다.  
변경 자체가 영향을 줄 수 있는 범위가 '변경된 것을 볼 수 있는 것들'로 한정하기 때문이다.  
캡슐화되는 것들이 많으면 그것들을 변경할 수 있는 여유도 많아 진다.  
이미 있는 코드를 바꾸더라도 사용자들밖에 영향을 주지 않는 융통성을 확보할 수 있다.  

어떤 객체의 모습을 그 객체의 데이터로 설명할수 있다고 하자.  
이 데이터를 직접볼 수 있는 코드가 적으면 적을수록 그 데이터는 많이 캡슐화된 것이고, 그 객체가 가진 데이터의 특징을 바꿀 수 있는 자유도가 그만큼 높다.  
어떤 데이터를 접근하는 함수가 많으면 그 데이터의 캡슐화 정도는 낮다는 이야기 이다.  

No.22 에서 보면 데이터 멤버는 private 멤버여야 한다.  
private 멤버가 아니면 이 데이터에 접근 할수 있는 함수의 개수를 프로그래머가 제한할수 없다.  
이런 데이터 멤버는 캡슐화의 보호막이 전혀 없다고 보면 된다.  
private 멤버로 되어 있는 데이터의 경우 여기에 접근할 수 있는 함수의 개수의 예측은 쉽다.  
그 클래스의 멤버함수의 개수에 프렌드 함수의 개수를 더하면 된다.  
private 멤버는 멤버함수와 프렌드 함수만 접근할수 있다.  

여기서 주의해야할 점은 두가지가 있다.  
첫째는 이 이야기가 비멤버 비프렌드 함수에만 적용된다.  
프렌드 함수는 private 멤버에 대한 접근권한이 해당 클래스의 접근권한과 똑같다. 그렇기 때문에 캡슐화에 대한 영향 역시 같다.  
캡슐화라는 관점에서 위의 선택은 멤버 함수와 비멤버 함수의 선택이 아니다.  
멤버함수와 비멤버 비프렌드 함수사이의 선택이다.  
(No.24 에서 암시적 타입변환의 관점에 멤버 함수 및 비 멤버 함수의 이야기 나온다.)  
두번째는 캡슐화에 대한 이런저런 이야기 때문에 '함수는 어떤 클래스의 비멤버가 되어야 한다'라는 주장이 '그 함수는 다른 클래스의 멤버가 될수 없다'라는 의미가 아니다.  
clearBrowser 함수를 다른 유틸리티 클래스 같은 데의 정적 멤버 함수로 만들어도 된다.  
이 함수가 WebBrowser 클래스의 멤버가 아니기만 하면 된다. WebBrowser 가 가진 private 멤버의 캡슐화에 영향을 주지 않는다는 점이 중요하다.  

C++로는 보다 더 자연스럽게 구사할수 있다.  
clearBrowser 를 비 멤버 함수로 두고, WebBrowser 클래스는 WebBrowserStuff 와 같은 네임 스페이스 안에 둔다.  

```c++
namespace WebBrowserStuff
{
    class WebBrowser
    {
        ...
    };

    void clearBrowser( WebBrowser & wb );
    ...
}
```

네임스페이스는 클래스와 달리 여러 개의 소스 파일에 나뉘어 흩어질수 있다.  
이 부분이 중요한데, clearBrowser 같은 함수들은 편의상 준비한 함수들이기 때문이다.  
멤버도 아니고 프렌드도 아니기에 WebBrowser 사용자는 아무리 애를 서도 얻어낼수 없는 기능은 이들도 제공할수 없다.  


WebBrowser 처럼 응용도가 높은 클래스는 이런 종류의 편의함수가 꽤 많이 생길수 있다.  
즐겨찾기 관련 함수나 쿠키 관련 함수들 같은 경우이다.  
왠만한 사용자는 이들 편의 함수들중 몇개만 필요할것이다.  
즐겨찾기 관련 함수만 사용하는 사용자는 쿠키 관련 함수에 대한 컴파일 의존성에 대해 고민할 필요가 없다.  
그래서 이들을 나누어 놓는 쉽고 깔끔한 방법은 즐겨찾기 관련 함수를 하나의 헤더 파일에 몰아서 선언하고 쿠키 관련 함수 역시 다른 헤더 파일에 몰아선 선언한다.  

```c++
// WebBrowser.h 헤더 - WebBrowser 클래스 자체에 대한 헤더
namespace WebBrowserStuff
{
    class WebBrowser
    {
        ...
    };
    ....
}

// WebBrowserBookmarks.h 헤더
namespace WebBrowserStuff
{
    ...                                          // 즐겨 찾기 관련 편의 함수
}

// WebBrowserCookies.h 헤더
namespace WebBrowserStuff
{
    ...                                          // 쿠키 관련 편의 함수
}
```

이렇게 하면 사용자가 실제로 사용하는 구성요소에 대해서만 컴파일러 의존성을 고려하면된다.  
(컴파일러 의존성을 줄이는 방법으로는 No.31 도 확인하자.)  
그러나 클래스 멤버 함수로 선언하면 그 전체가 통으로 정의되어야 하고 여러 조각으로 나눌수 없다.  

편의 함수 전체를 여러개의 헤더 파일에 나누어 놓으면 편의 함수 집합의 확장도 쉬워진다.  
해당 네임스페이스에 비 멤버 비 프렌드 함수를 원하는 만큼 추가해 주기만 하면 된다.  

> 멤버 함수보다는 미 멤버 비 프렌드 함수를 자주 쓰도록 하자.  
> 캡슐화 정도가 높아지고 패키지 유연성도 커지며, 기능적 확장성도 늘어난다.    

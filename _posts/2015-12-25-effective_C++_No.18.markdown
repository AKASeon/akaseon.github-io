---
layout: post
title:  "Effective C++ No.18. 인터페이스 설계는 제대로 쓰기 쉽게, 엉터리로 쓰기는 어럽게 하자"
date: 2015-12-25
categories: jekyll update
---

'제대로 쓰기에 쉽고, 엉터리로 쓰기에 어려운' 인터페이스를 개발하려면 우선 사용자가 저지를 만한 실수의 종류를 생각해야 한다.  

```c++
class date
{
public:
    Date( int month, int day, int year );
    ...
};
```

```c++
// 3, 30 이어야 하는데 30, 3 을 전달
Date( 30, 3, 1995 );        
// 3, 30 이어야 하는데 3, 40 를 전달            
Date( 3, 40, 1995 );                    
```

새로운 타입을 들여와 인터페이스를 강화하면 상당수의 사용자 실수를 막을수 있다.  
지금의 경우 간단한 일, 월, 년을 구분하는 간단한 랩퍼 타입을 만들고 이 타입을 Date 의 생성자안에 둘수 있다.  

```c++
struct Day
{
    explicit Day( int d ) : val ( d )
    {
    }

    int val;
}

struct Month
{
    explicit Month( int m ) : val ( m )
    {
    }

    int val;
}

struct Year
{
    explicit Year( int y ) : val ( y )
    {
    }

    int val;
}

class Date
{
public:
    Date( const Month & m, const Day & d, const Year & y );
    ...
};

// 타입이 잘못 되었음
Date d( 30, 3, 1995 );
// 타입이 잘못 되었음
Date d( Day(30), Month(3), Year(1995) );

// 정상
Date d( Month(3), Day(30), Year(1995) );
```

Day 및 Month, Year 에 데이터를 이것저것 숨겨 넣어 제몫을 하는 온전한 클래스로 만들면 위의 단순한 구조체 보다 확실히 낫지만 (No. 22)
타입을 적절히 새로 준비해 두기만 해도 인터페이스 사용 에러를 막는데는 약발이 통한다.  

적절한 타입만 제대로 준비되어 있으면 각 타입의 값에 제약을 가하더라도 괜찮은 경우가 있다.  
예를 들면 월을 가질수 있는 유효한 값은 12개 뿐이므로 Month 타입은 이 사실을 제약으로 사용할수 있다.  
한가지 방법으로는 enum 으로 선언할수 있다.  그러나 enum 은 타입 안전성은 그리 믿음직하지 못하다.
그리고 enum 은 int 처럼 사용 될수도 있다.(No.2 참조)  
타입 안전성이 신경 쓰인다면 유효한 Month 의 집합을 미리 정의해 두어도 괜찮다.  

```c++
class Month
{
public:
    static Month Jan() { reutrn Month(1); }
    static Month Feb() { return Month(2); }
    ...
    static Month Dec() { return Month(12); }
    ...

private:
    explicit Month( int m );
    ....
};

Date d( Month::Mar(), Day(30), Year(1995) );
```

특정한 월을 나타내는 데 객체를 쓰지 않고 함수를 쓴것은 비 지역 정적 객체들의 초기화를 믿고 밀고 나가는것은 그 자체로 문제가 있다.(No.4)  

예상되는 사용자 실수를 막는 다른 방법으로는 어떤 타입이 제약을 부역하여 그타입을 통해 할수 있는 일들을 묶어 버리는 방법이 있다.  
제약 부여 방법으로 아주 흔히 쓰이는 예가 'const' 붙이기 이다.  
No.3 에서 operator * 의 반환 타입을 const 로 한정함으로써 사용자가 사용자 정의 타입에 대해 다음과 같은 실수를 저지르지 않도록 한다.  

```c++
if ( a * b = c )
...
```

'그렇게 하지 않을 번듯한 이유가 없다면 사용자 정의 타입은 기본제공 타입처럼 동작하게 만들어라' 라는 지침을 따라야 한다.  
int 등의 타입정도는 사용자들이 이미 그 성질을 알고 있기 때문에 사용자를 위해 만드는 타입도 웬만하면 이들과 똑같이 동작하도록하는게 좋다.  
int 와 굳이 다른 길을 걸어갈 이유가 없다면 새로 만드는 타입에서도 이게 말이 안되어야 한다.  
아리송하면 int 의 동작 원리대로 만들자.  

기본 제공 타입과 쓸데 없이 어긋나는 동작을 피하는 실질적인 이유는 일관성 있는 인터페이스를 제공하기 위해서 이다.  
STL 컨테이너의 인터페이스는 전반적으로 일관성으로 가지고 있다. 그렇기 때문에 사용하는데 큰 부담이 없다.  

사용자 쪽에서 뭔가를 외워야 제대로 쓸수 있는 인터페이스는 잘못 쓰기 쉽다.  

```c++
// No.13 에서 가져온 함수
Investment * createInvestment();
```

이 함수를 사용할때 자원 누출을 피하기 위해서 createInvestment 에서 얻어낸 포인터를 나중에라도 삭제해야 한다.  
그런데 이 때문에 실수를 최소한 2가지를 저지를수 있다.  
하나는 포인터 삭제를 안하는 것이고, 다른 하나는 똑같은 포인터에 대해서 delete 가 두번 이상 적용되는 것이다.  

No.13 이후를 보면 createInvestment 의 반환값을 auto_ptr 이나 tr1::shared_ptr 등의 스마트 포인터에 저장한 후에 해당 포인터의 삭제 작업을 스마트 포인터에 위임하는 방법이 있다.  
그러나 이것은 사용자가 스마트 포인터를 사용해야 한다는 사실을 잊어 버릴수 있다.  
애초부터 팩토리 함수가 스마트 포인터를 반환하게 만들면 위와 같은 문제가 사라 진다.  

```c++
std::tr1::shared_ptr<Investment> createInvestment();
```

이 함수의 반환 값은 tr1::shared_ptr 에 넣어둘수 밖에 없고 Investment 객체가 필요 없어 졌을때 삭제를 잊었더라도 스마트 포인터가 대신 처리해준다.  
사실 tr1::shared_ptr 을 반환하는 구조는 자원 해제에 관련된 상당수의 사용자 실수를 사전 봉쇄할수도 있어서 여러모로 인터페이스 설계자에게 좋다.  
No.14에서 이야기 했듯이 tr1::shared_ptr 은 생성시점에 자원해제 함수를 직접 엮을수 있는 기능을 갖고 있다.(auto_ptr은 이런 기능이 없다.)  

createInvestment 를 통해 얻은 Investment * 포인터를 직접 삭제하지 않게 하고 getRidOfInvestment 라는 이름의 함수를 이용하여 여기에 넘기게 하면 어떻게 될까?   
더 깔끔해 보이기는 하지만 이런 인터페이스는 사용자의 실수를 하나더 가지고 올수 있다.  
자원 해제 매커니즘을 잘못 사용 할수가 있다.(getRidOfInvestment 를 잊어버리고 delete 를 사용할수 있다.)  
createInvestment 를 조금 고쳐서 getRidOfInvestment 가 삭제자로 묶인 tr1::shared_ptr 을 반환하도록 구현해 둔다면 이런 문제를 막을수 있다.  

tr1::shared_ptr 에는 2개의 인자를 받는 생성자가 있다.  
첫번째 인자는 스마트 포인터로 관리해야할 실제 포인터이고, 두번째 인자는 참조 카운트가 0 이 될때 호출될 삭제자 이다.  

```c++
// 첫번째 인자로 0 을 넘겨주었기 때문에 컴파일이 되지 않는다.
std::tr1::shared_ptr<Investment> pInv( 0, getRidOfInvestment );
```

tr1::shared_ptr 의 생성자의 첫번째 매개변수로 포인터를 받아야 한다.  
그런데 0은 포인터가 아니라 int 이다.  
0 을 포인터로 변환할수 있지만 tr1::shared_ptr 에서 원하는 포인터는 Investment * 타입의 실제 포인터이다.  
그래서 캐스트를 적용하여 컴파일이 가능하게 한다.  

```c++
std::tr1::shared_ptr<Investment> pInv( static_cast<Investmen*t>(0),
                                       getRidOfInvestment );
```

```c++
std::tr1::shared_ptr<Investment> createInvestment()
{
    std::tr1::shared_ptr<Investment> retVal( static_cast<Investment*>(0),
                                             getRidOfInvestment );

    retVal = ...;

    return retVal;
}
```

retVal 로 관리할 실제 객체의 포인터를 결정하는 시점이 retVal 을 생성하는 시점보다 앞설수 있다.  
위 코드 처럼 retVal 을 Null 로 초기화 하고 나중에 대입하는 방법보다 실제 객체의 포인터를 바로 retVal 의 생성자로 넘겨 버리는것이 낫다.(No.26 참조)

tr1::shared_ptr 에는 엄청 좋은 특징이 하나 있다.  
바로 포인터별 삭제자를 자동으로 씀으로써 사용자가 저지를수 있는 실수를 방지 한다.  
여기서 사용자가 저지를수 있는 실수는 교차 DDL 문제이다.  
이 문제는 객체 생성시에 어떤 동적 링크 라이브러리(DLL)의 new 를 사용하였는데 그 객체를 삭제할 때는 이전의 DDL 과 다른 DDL에 있는 delete 를 사용할수 있다.  
이렇게 new/delete 짝이 실행되는 DDL 이 달라서 꼬이게 되면 대다수의 플랫폼에서 런타임 에러가 발생한다.  
이러한 문제를 tr1::shared_ptr 를 사용하면 방지 할수 있다.  
이 클래스의 기본 삭제자는 tr1::shared_ptr 이 생성된 DDL 과 동일한 DDL 에서 delete 를 사용하도록 만들어져 있다.  

tr1::shared_ptr 을 구현한 제품중 가장 흔히 사용하는것이 부스트 라이브러리 이다.(No.55 참조)  
부스트의 shared_ptr 은 일단 크기가 원시 포인터의 두배이다.  
그리고 내부 관리 데이터 및 삭제자 매커니즘을 돌릴 데이터를 위해 동적 할당 메모리를 사용한다.  
그리고 다중 쓰레드로 돌아 가는 프로그램을 지원할 경우에는 참조 카운트를 변경 할때 쓰레드 동기화 오버헤드를 발생시킨다.  
(다중 쓰레드 지원을 비활성화 시킬수 있다. 선행 처리자 기호를 정의하면 된다.)  
간단히 말해 이 클래스를 사용하면 원시 포인터 보다 크고 느리며 게다가 내부 관리용 동적 메모리까지 추가로 매달린다.  
하지만 이런 것들 때문에 응용 프로그램에서 런타임 비용이 눈에 띄게 줄어드는 경우는 어지간해서 찾기 힘들다.  
반면에 사용자 실수가 눈에 띄게 줄어드는 경우는 모든 사람이 잡아 낼수 있다.  

> 1. 좋은 인테페이스는 제대로 쓰기에 쉬우며 엉터리로 쓰기에는 어렵다.  
>    인터페이스를 만들때는 이 특성을 지닐수 있도록 고민하고 또 고민하자.  
> 2. 인터페이스의 올바른 사용을 이끄는 방법으로는 인터페이스 사이의 일관성을 잡아주기,
     그리고 기본 제공 타입과의 동작 호환성 유지하기가 있다.  
> 3. 사용자의 실수를 방지하는 방법으로는 새로운 타입 만들기, 타입에 대한 연산 제한하기,
     객체의 값에 대해 제약 걸기, 자원 관리 작업을 사용자 책임으로 놓지 않기가 있다.  
> 4. tr1::shared_ptr 은 사용자 정의 객체 삭제자를 지원한다.  
>    이 특징 때문에 tr1::shared_ptr 은 교차 DDL 문제를 막아 준다.  
>    뮤텍스 등의 자동으로 잠금 해제하는 데 (No.14 참조) 쓸수 있다.  

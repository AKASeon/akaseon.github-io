---
layout: post
title:  "Effective C++ No.22 데이터 멤버가 선언될 곳은 private 영역임을 명심하자"
date: 2015-12-29
categories: jekyll update
---

public 을 사용하면 안되는 이유에 대해서 말한다.  

문법적 일관성이 첫번째 이유이다.  
데이터 멤버가 public 이 아니라면, 사용자 쪽에서 어떤 객체를 접근할수 있는 유일한 수단은 멤버 함수이다.  
어떤 클래스의 공개 인터페이스에 있는 것들이 전부 함수 뿐이라면, 그 클래스의 멤버에 접근하고 싶을때 함수를 통하여 접근을 하면 된다.  
굳이 직접 접근을 해야 하는 고민을 할 필요가 없다.  

함수를 사용하면 데이터 멤버의 접근성에 대해 훨씬 정교한 제어를 할수 있다.    
어떤 데이터 멤버를 public 으로 선언하였으면 모두가 이 멤버에 대해 읽기 및 쓰기 접근 권한을 가지게 된다.  
그렇지만 private 으로 선언하고 함수를 통하여 제어하게 되면 어떤 데이터 멤버에 대해 읽는 함수, 쓰는 함수에 땨라 접근 권환을 줄수 있다.  

```c++
class AccessLevels
{
public:
    ...
    int getReadOnly() const            { return readOnly; }

    void setReadWrite( int value )     { readWrite = value; }
    int getReadWrite() const           { return readWrite; }

    void setWriteOnly( int value )     { writeOnly = value; }

private:
    int noAccess;
    int readOnly;
    int readWrite;
    int writeOnly;
};
```

이렇게 세밀한 접근 제어는 나름대로 중요성을 갖고 있다.  
어떤 식으로든 외부에 노출시키면 안되는 데이터 멤버들이 존재한다.  

또다른 이유는 캡슐화(encapsulation) 이다.  
함수를 통하여서만 데이터 멤버에 접근할 수 있도록 구현해 두면, 데이터 멤버를 나중에 계산식으로 대체할수도 있다.  

```c++
class SpeedDataCollection
{
    ...
public:
    void addValue( int speed );                  // 새 데이터를 추가한다.  

    double averageSoFar() const;                 // 평균 속도를 반환한다.  
};
```

averageSoFar 멤버 함수의 구현을 보면 한가지 방법으로, 지금까지 수집한 속도 데이터를 전체의 평균값에 담는 어떤 데이터 멤버를 클래스 안에 둘수 있다.  
averageSoFar 함수는 호출될 때 마다 그 데이터 멤버의 값을 반환하면 된다.  
다른 방법으로는 호출될때마다 평균값을 계산하는 방법이 있다.  
이 방법은 수집한 데이터를 매번 읽는 코드가 들어가야 한다.  

첫번째 방법을 사용하면 SpeedDataCollection 객체 하나의 크기가 조금 커진다.  
평균값을 유지하기 위한 공간할당이 필요하다.  
현재의 평균값, 누적의 총합, 데이터의 개수등이 데이터 멤버로 추가적으로 필요하다.  
다른 방법은 호출될때 마다 평균값을 계산하는 방법을 쓰면 함수자체의 속도는 느리지만 SpeedDataCollection 객체 하나의 크기는 첫번째 방법보다 작을 것이다.  

메모리가 빡빡한 환경이고, 평균값이 그다지 필요하지 않은 응용프로그램이라면 평균값 계산을 매번하는 편이 좋다.  
그러나 평균값을 빈번하게 사용하고 속도가 중요하며 메모리 크기에 구애받지 않는 환경이라면 평균값을 유지하는 편이 좋다.  

데이터 멤버를 함수 인터페이스 뒤에 감추게 되면 구현상의 융통성을 전부 누릴수 있다.  
예를 들면 데이터 멤버를 읽거나 쓸때 다른 객체에 알림 메시지를 보낸다던지, 클래스의 불변속성 및 사전조건, 사후조건을 검증한다던지, 쓰레드 환경에서 동기화를 거는 작업들을 쉽게 할수 있다.  

캡슐화는 매우 중요하다.  
사용자로부터 데이터 멤버를 숨기면 클래스의 불변속성을 항상 유지하는데 소홀해질 수 없다.  
불변속성을 보여줄수 있는 통로가 멤버 함수밖에 없기 때문이다.  
그뿐 아니라 캡슐화는 현재의 구현을 나중에 바꾸는 작업을 보다 쉽게 할수 있게 해준다.  
public 으로 선언된 부분은 손을 대기가 힘들다.  손을 대면 사용자의 코드가 깨질수 있다.  
c++ 에서 public 은 '캡슐화되지 않았다'라는 의미 이다.  
실질적 측면에서 이야기할 때 '캡슙화되지 않았다'라는 말은 '바꿀수 없다'라는 의미를 가지고 있다.  

protected 데이터 멤버의 경우도 앞에서 말한 문제들을 가지고 있다.  
public 데이터 멤버 보다는 많이 가려져 있지만 파생 클래스들에서 코드를 참조할수 있다.  
No.23 을 보면 어떤 것이 바뀌면 깨질 가능성을 가진 코드가 늘어날 때 캡슐화의 정도는 그의 반비례해서 작아진다.  




> 1. 데이터 멤버는 private 으로 선언하자.  
>    이를 통해 클래스 제작자는 문법적으로 일관성있는 데이터 접근 통로를 제공할수 있다.  
>    필요에 따라서는 세밀한 접근제어도 가능하며, 클래스의 불변속성을 강화할 수 있다.
>    그리고 내부 구현의 융통성도 가질수 있다.  
> 2. protected 는 public 보다 더 많의 '보호'받고 있는 것이 절대 아니다.  

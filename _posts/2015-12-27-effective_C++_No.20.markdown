---
layout: post
title:  "Effective C++ No.20 '값에 의한 전달' 보다 '상수 객체 참조자에 의한 전달' 방식을 택하는 편이 대개 낫다"
date: 2015-12-27
categories: jekyll update
---

기본적으로 C++는 함수로부터 객체를 전달 받거나 함수에 객체를 전달 할때 '값에 의한 전달(pass-by-value)'방식을 사용한다.  
특별히 다른 방식을 지정하지 않는한, 함수 매개변수는 신제 인자의 '사본'을 통해 초기화되며, 어떤 함수를 호출한 쪽은 그 함수가 반환한 값의 '사본'을 돌려 받는다.  
이들 사본을 만들어내는 원천이 바로 복사 생성자이다.  
이것 때문에 '값에 의한 전달'이 고비용 연산이 되기도 한다.  

```c++
class Room
{
public:
    Person();
    virtual ~Person();
    ...

private:
    std::string name;
    std::string address;
};

class Student : public Person
{
public:
    Student();
    ~Student();
    ..

private:
    std::string schoolName;
    std::string schollAddress;
};
```

```c++
bool validateStudent( Student s );

Student plato;
bool platoIsOK = validateStudent( plato );
```

plato 로 부터 매개변수 s 를 초기화 시키기 위해 Student 복사 생성자가 호출된다.  
게다가 s 는 validateStudent 가 복귀 할때 소멸될 것이다.  
이 함수 매개변수 전달 비용은 Student 복사 생성자 호출 한번, 소멸자 호출 한번이다.  
Student 객체에는 std::string 객체가 두개가 멤버로 있기 때문에 Student 객체가 생성될때마다 이들 string 도 생성된다.  
그리고 Student 객체는 Person 객체에서 파생되었기 때문에 Student 객체가 생성되면 Person 객체가 먼저 생성되어야 한다.  
Person 객체도 std::string 객체를 두개를 맴버로 가지고 있기 때문에 이 또한 string 객체를 생성한다.  
단지 Student 객체 하나를 값으로 전달 하였을 뿐인데 Student 복사 생성자 한번 Person 복사 생성자 한번, String 복사 생성자 호출이 네번 일어난다.  
Student 객체의 사본이 소멸 될때도 마찬가지이다.  
앞에 호출된 생성자들이 각각이 소멸자 호출과 대응된다.
간단히 말하면 Student 객체를 값으로 전달 하였을때 비용은 생성자 여섯번에 소멸자 여섯번이다.  

생성자 소멸자 호출을 몇번 거치지 않고 넘어 갈수 있는 방법은 '상수객체에 대한 참조자(reference-to-const)로 전달' 이다.  

```c++
bool validateStudent( const Student & s );
```

이렇게 코드를 변경하면 훨씬 효율적인 코드이다.  
새로 만들어지는 객체는 없고, 생성자와 소멸자도 전혀 호출되지 않는다.  
또 여기서 중요한 것은 매개 변수에 있는 const 이다.  
원래의 validateStudent 는 Student 의 값을 전달 받도록 되어 있었기 때문에 이 함수 안에서 생기는 변화에 대해서 안전하게 보호 받는다.  
그렇지만 참조로 전달하면 이 함수 안에서의 변화가 함수 밖으로 전파될수 있다.  
그렇기 때문에 const 를 붙여 값이 변경되지 못하도록 한다.  

참조에 의한 전달 방식으로 매개 변수를 넘기면 복사손실 문제(slicing problem)가 없어지는 장점도 있다.  
파생 클래스 객체가 기본 클래스 객체로서 전달되는 경우가 드물지 않게 있다.  
이 경우 이 객체가 값으로 전달되면 기본 클래스의 복사 생성자가 호출되고 파생 클래스 객체로 동작하게 해 주는 특징들이 없어지게 된다.  

```c++
class Window
{
public:
    ...
    std::string name() const;
    virtual void display() const;
};

class WindowWithScrollBars : public Window
{
public:
    ...
    virtual void display() const;
};
```

No.34 No.36 에서 보다 잘 구현된 WindowWithScrollBars 객체를 확인하자.  

```c++
void printNameAndDisplay( Window w )
{
    std::cout << w.name();
    w.display();
}
```

```c++
WindowWithScrollBars wwsb;

printNameAndDisplay( wwsb );
```

WindowWithScrollBars 객체를  printNameAndDisplay 의 매개변수로 넘겨주면 wwsb 객체는 Window 복사 생성자에 의해 Window 객체로 변화하게 된다.  
이때 WindowWithScrollBars 객체가 가지고 있던 특징들이 사리지게 된다.  

복사손실 문제를 해결하기 위해서는 w 를 상수객체에 대한 참조자로 전달하도록 한다.  

```c++
void printNameAndDisplay( const Window & w )
{
    std::cout << w.name();
    w.display();
}
```

이렇게 하면 w 가 어떤 종류의 윈도우가 넘겨지더라도 그 윈도우의 성질을 그대로 갖게 된다.  

참조자를 전달하는것은 결국 포인터를 전달하는것과 같다.  
그래서 전달하는 객체의 타입이 기본제공 타입(int 등)일 경우에는 참조자로 넘기는 것보다 값으로 넘기는 편이 더 효율적일때가 많다.  
그러니깐 '값에 의한 전달' 및 '상수 객체의 참조에 의한 전달'중 하나를 선택해야할 때, 기본제공 타입에 대해서는 '값에 의한 전달'을 선택하더라도 엉터리가 아니라는 이야기 이다.  
이 점은 STL의 반복자와 함수 객체에 대해서도 마찬가지이다.  
예전부터 반복자와 함수 객체는 값으로 전달되도록 설계해 왔기 때문이다.  
반복자와 함수 객체를 구현할때는 아래 두 항목이 필수 이다.  
1. 복사 효율을 높을것  
2. 복사손실 문제에 노출되지 않도록 만드는것  

기본 제공타입은 작다.   
그렇기 때문에 타입크기가 작으면 전부 '값에 의한 전달'을 할수 있다라고 생각 할수 있다. 사용자 정의 타입이라도...  
'그냥 크기가 작으니깐'는 그 객체 복사 생성자 호출이 저 비용이라는 뜻으로 해석하는 단서가 아니다.  
데이터 멤버라고 해봐야 달랑 포인터 하나뿐인 객체가 꽤 많이 있다.  
그렇지만 이런 객체를 복사하는데는 그 포인터멤버가 가리키는 대상까지 복사하는 작업도 따라다녀야 한다.  
크기가 작다고 쉽지 않다. 오히러 복사 비용이 비쌀수도 있다.  

객체 크기가 작고 복사 생성자도 그다지 비싸지 않게 만들었다고 가정해도 문제가 더 있다.  
수행 성능 문제가 발목을 잡을수 있다.  
컴파일러중에는 기본제공 타입과 사용자 정의 타입을 아예 다르게 취급하는것도 있다.  
기본 제공 타입과 사용자 정의 타입의 하부 표현구조가 같아도 다를수 있다.  
에를 들면 double 은 레지스터에 넣어 주지만 double 하나로만 만들어진 객체는 레지스터에 넣지 않는다.  
이런 개발 환경에서는 차라리 참조에 의한 전달을 쓰는 편이 좋다.  
왜나하면 포인터(참조자가 포인터로 구현..)는 레지스터에 확실히 들어 간다.    

크기가 작다해서 작은 사용자 정의 타입을 무조건 값으로 전달할 수 없는 이유가 하나 더 있다.  
사용자 정의 타입은 언제든 변화에 노출되어 있다.  
지금은 크기가 작을지 몰라도 나중에는 커질수 있다.  
심지어 다른 c++ 구현 환경으로 바꿀때조차 사정이 변화한다.  
표준 라이브러리의 string 타입이 그 크기가 최고 일곱배나 차이가 나는 경우도 있다.  

일반적으로 '값에 의한 전달'이 저 비용이라고 가정해도 괜찮은 유일한 타입은 기본제공 타입, STL 반복자, 함수객체 타입 이렇게 세개뿐이다.  
이 외의 타입에 대해서는 이번항목에 나온 이야기를 따르는것이 좋다.  
'값에 의한 전달'보다는 '상수 객체 참조자에 의한 전달'을 선택하라.  


> 1. '값에 의한 전달'보다는 '상수 객체 참조자에 의한 전달'을 선호한다.  
>    대체적으로 효율적일 뿐만 아니라 복사손실 문제까지 막아 준다.  
> 2. 이번 항목에서 다룬 법칙은 기본제공 타입 및 STL 반복자, 그리고 함수 객체 타입에는 맞지 않다.  
>    이들에 대해서는 '값에 의한 전달'이 더 적절하다.  
